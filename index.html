<html>
<meta charset='utf-8'/>
<canvas id="myCanvas" width="887" height="87">
Your browser does not support the HTML5 canvas tag.
</canvas>


<script>

var OPCArt = function(element, pixelPos) {
    this.element = element;
    this.ctx = element.getContext("2d");
    this.pixelPos = pixelPos;

    this.pixels = new Array(pixelPos.length);
    for(var i=0; i < pixelPos.length; i++) {
        this.pixels[i] = [0, 0, 0];
    }

    this.drawInterval = setInterval(this.draw.bind(this), 16);
}

OPCArt.arts = [];

OPCArt.prototype.draw = function() {
    this.ctx.clearRect(0, 0, this.element.width, this.element.height);

    for(i=0; i< 96; i++) {
        this.ctx.fillStyle = "rgb(" + this.pixels[i][0] + ", " +
                                      this.pixels[i][1] + ", " +
                                      this.pixels[i][2] + ")";
        this.ctx.fillRect.apply(this.ctx, this.pixelPos[i]);
    }
}

function buildPixelPos() {
    var paneHeight = 87;
    var paneWidth = 82;
    var paneSep = 33;
    var border = 2;
    var winWidth = (paneWidth - 4 * border) / 3;
    var winHeight = (paneHeight - 3 * border) / 2;

    var pixelPos = new Array(96);
     
    for(var i=0;i<pixelPos.length;i++) {

        var pane = Math.floor(i / 12);
        var x = Math.floor(i / 4) % 3;
        var y = i % 4;

        pixelPos[i] = [
            pane * (paneWidth + paneSep) + x * winWidth + border * (x+1),
            y*winHeight/2 + (1+ Math.floor(y / 2)) * border,
            winWidth,
            Math.ceil(winHeight / 2)
        ];
    }
    return pixelPos;
}
////// ART

function Art() {}

Art.prototype = {
    updateMilliseconds: 100, // Time to wait between updating this art.
                             // The renderer targets 60 FPS, so there's no need
                             // to attempt to exceed 16ms.
    start: function start(OPC) {
        // Start the art.  Starts a frame counter and initializes the interval
        // callback function.

        this.pixels = OPC.pixels;
        this.frameNumber = 0;
        this.updateInterval = setInterval(this.nextFrame.bind(this),
                                          this.updateMilliseconds);
    },

    stop: function stop() {
        // Stop the art.
        clearInterval(this.updateInterval);
    },

    nextFrame: function nextFrame() {
        // Advance the frame count and invoke the art specific update method.
        this.frameNumber += 1;
        this.update.call(this);
    },

    update: function() {
    },
}
//// ExampleArt suitable for lots of copy pasta.

function ExampleArt() {}
ExampleArt.prototype = Object.create(Art.prototype);
ExampleArt.prototype.description = "Copy Pasta me to create new art.";

ExampleArt.prototype.start = function start(OPC) {
    Art.prototype.start.apply(this, arguments);
    // Initialize any art specific data here.  `this` provides storage for any
    // locals you want to persist state for.
}
ExampleArt.prototype.stop = function start() {
    Art.prototype.stop.apply(this, arguments);
    // Cleanup any locally allocated data here if required.
    // Many art implementations may choose to ignore this method.
}

ExampleArt.prototype.update = function update() {
    // The super method does nothing here so not including it as a template.
    // This method should update the this.pixels array for a new frame.
}

/// Gradient
function wrapIndex(i, i_max) {
   return ((i % i_max) + i_max) % i_max;
}

function Gradient() {}
Gradient.prototype = Object.create(Art.prototype);
Gradient.prototype.description = "Cycle single color gradients on each face.";

Gradient.prototype.update = function() {
    for(i=0;i<this.pixels.length;i++) {
        var pane = Math.floor(i / (12));
        var x = Math.floor((i % 12) / 4);
        var y = ((i % 12) % 4);
        var channel = Math.floor((pane % 6)/2);
        if(pane<2) {
            this.pixels[i][channel] = Math.min(255, Math.abs(wrapIndex(8*(x + this.frameNumber), 512) - 256));
        } else if (pane < 4) {
            this.pixels[i][channel] = Math.min(255, Math.abs(wrapIndex(8*(y + this.frameNumber+8), 512) - 256));
        } else if (pane < 6) {
            this.pixels[i][channel] = Math.min(255, Math.abs(wrapIndex(8*(x - this.frameNumber-16), 512) - 256));
        } else {
            this.pixels[i][0] =
            this.pixels[i][2] = Math.min(255, Math.abs(wrapIndex(8*(y - this.frameNumber-24), 512) - 256));
        }
    }
}


//// Initialize and start the art.

var c = document.getElementById("myCanvas");
var pixelPos = buildPixelPos();
var OPC = new OPCArt(c, pixelPos);

art = new Gradient();
art.start(OPC);

</script>
</html>
